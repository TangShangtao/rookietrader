<font size="6">**交易系统各业务接口代码示例**</font><br>

<font size="6">文档说明</font>

<table><tbody>
    <tr>
        <th>日期</th><th>版本</th><th>修订摘要</th>
    </tr>
    <tr>
        <td>20241209</td><td>1.0.0</td><td>初版</td>
    </tr>
</table>


<font size="6">前言</font>

本接口规范用以指导开发通过 EMTAPI 对接的方式访问东财快速交易系统，进行现货/两融/期权各业务下单示例代码。

## 1. 普通股票委托示例

```c++
uint64_t InsertOrder(TraderApi* m_pTraderApi, uint64_t session_id)
{
    //EMTOrderInsertInfo 为下单参数结构体
    EMTOrderInsertInfo order;
    //结构体初始化
    memset(&order, 0, sizeof(EMTOrderInsertInfo));
    //报单引用,由客户自定义
    order.order_client_id = 111111;
    //股票代码
    std::string ticker = "300059";
    strncpy(order.ticker, ticker, EMT_TICKER_LEN);
    //市场参数
    order.market = EMT_MKT_SZ_A;
    //价格(可参考行情修改)
    order.price = 27.5;
    //委托数量
    order.quantity = 1000;
    //价格类型(可参考API文档定义类型 EMT_PRICE_TYPE)
    order.price_type = EMT_PRICE_LIMIT;
    //买卖方向(EMT_SIDE_BUY/EMT_SIDE_SELL)
    order.side = EMT_SIDE_BUY;
    //开平标志(除期权外,均使用EMT_POSITION_EFFECT_INIT)
    order.position_effect = EMT_POSITION_EFFECT_INIT;
    //业务类型
    order.business_type = EMT_BUSINESS_TYPE_CASH;
    //报盘网关号,仅具备指定报盘通道权限的客户支持
    order.offer_tgw_id = 0;
    //调用api接口委托前基本校验
    if (m_pTraderApi && session_id != 0)
    {
        //返回报单在EMT系统中的ID,如果为“0”表示报单发送失败
        uint64_t nEmtId = m_pTraderApi->InsertOrder(&order, session_id);
        //下单发送失败
        if (nEmtId == 0)
        {
            //获取错误代码
            EMTRI *error = m_pTraderApi->GetApiLastError();
        }
    }
}
```

## 2. 新股申购委托示例

```c++
uint64_t InsertOrder(TraderApi* m_pTraderApi, uint64_t session_id)
{
    //EMTOrderInsertInfo 为下单参数结构体
    EMTOrderInsertInfo order;
    //结构体初始化
    memset(&order, 0, sizeof(EMTOrderInsertInfo));
    //报单引用,由客户自定义
    order.order_client_id = 111111;
    //股票代码
    std::string ticker = "300059";
    strncpy(order.ticker, ticker, EMT_TICKER_LEN);
    //市场参数
    order.market = EMT_MKT_SZ_A;
    //新股申购价格可填0
    order.price = 0;
    //申购数量
    order.quantity = 100;
    //价格类型(新股申购业务需选择限价类型)
    order.price_type = EMT_PRICE_LIMIT;
    //买卖方向(EMT_SIDE_BUY)
    order.side = EMT_SIDE_BUY;
    //开平标志(除期权外,均使用EMT_POSITION_EFFECT_INIT)
    order.position_effect = EMT_POSITION_EFFECT_INIT;
    //业务类型 新股申购
    order.business_type = EMT_BUSINESS_TYPE_IPOS;
    //调用api接口委托前基本校验
    if (m_pTraderApi && session_id != 0)
    {
        //返回报单在EMT系统中的ID,如果为“0”表示报单发送失败
        uint64_t nEmtId = m_pTraderApi->InsertOrder(&order, session_id);
        //下单发送失败
        if (nEmtId == 0)
        {
            //获取错误代码
            EMTRI *error = m_pTraderApi->GetApiLastError();
        }
    }
}
```

## 3. 配股配债委托示例

```c++
uint64_t InsertOrder(TraderApi* m_pTraderApi, uint64_t session_id)
{
    //EMTOrderInsertInfo 为下单参数结构体
    EMTOrderInsertInfo order;
    //结构体初始化
    memset(&order, 0, sizeof(EMTOrderInsertInfo));
    //报单引用,由客户自定义
    order.order_client_id = 111111;
    //股票代码
    std::string ticker = "080065";
    strncpy(order.ticker, ticker, EMT_TICKER_LEN);
    //市场参数
    order.market = EMT_MKT_SZ_A;
    //配股配债价格填0
    order.price = 0;
    //申购数量
    order.quantity = 1000;
    //价格类型(配股配债业务需选择限价类型)
    order.price_type = EMT_PRICE_LIMIT;
    //买卖方向(EMT_SIDE_BUY)
    order.side = EMT_SIDE_BUY;
    //开平标志(除期权外,均使用EMT_POSITION_EFFECT_INIT)
    order.position_effect = EMT_POSITION_EFFECT_INIT;
    //业务类型 配股业务
    order.business_type = EMT_BUSINESS_TYPE_ALLOTMENT;
    //调用api接口委托前基本校验
    if (m_pTraderApi && session_id != 0)
    {
        //返回报单在EMT系统中的ID,如果为“0”表示报单发送失败
        uint64_t nEmtId = m_pTraderApi->InsertOrder(&order, session_id);
        //下单发送失败
        if (nEmtId == 0)
        {
            //获取错误代码
            EMTRI *error = m_pTraderApi->GetApiLastError();
        }
    }
}
```

## 4. ETF申赎委托示例

```c++
uint64_t InsertOrder(TraderApi* m_pTraderApi, uint64_t session_id)
{
    //EMTOrderInsertInfo 为下单参数结构体
    EMTOrderInsertInfo order;
    //结构体初始化
    memset(&order, 0, sizeof(EMTOrderInsertInfo));
    //报单引用,由客户自定义
    order.order_client_id = 111111;
    //股票代码
    std::string ticker = "159001";
    strncpy(order.ticker, ticker, EMT_TICKER_LEN);
    //市场参数
    order.market = EMT_MKT_SZ_A;
    //ETF申赎此字段建议为0
    order.price = 0;
    //ETF申赎此字段要为最小申赎单位整数倍
    order.quantity = 100;
    //价格类型(ETF申赎业务需选择限价类型)
    order.price_type = EMT_PRICE_LIMIT;
    //ETF 申购EMT_SIDE_PURCHASE,赎回EMT_SIDE_REDEMPTION
    order.side = EMT_SIDE_PURCHASE;
    //开平标志(除期权外,均使用EMT_POSITION_EFFECT_INIT)
    order.position_effect = EMT_POSITION_EFFECT_INIT;
    //业务类型 ETF申赎业务
    order.business_type = EMT_BUSINESS_TYPE_ETF;
    //调用api接口委托前基本校验
    if (m_pTraderApi && session_id != 0)
    {
        //返回报单在EMT系统中的ID,如果为“0”表示报单发送失败
        uint64_t nEmtId = m_pTraderApi->InsertOrder(&order, session_id);
        //下单发送失败
        if (nEmtId == 0)
        {
            //获取错误代码
            EMTRI *error = m_pTraderApi->GetApiLastError();
        }
    }
}
```

## 5. 国债逆回购委托示例

```c++
uint64_t InsertOrder(TraderApi* m_pTraderApi, uint64_t session_id)
{
    //EMTOrderInsertInfo 为下单参数结构体
    EMTOrderInsertInfo order;
    //结构体初始化
    memset(&order, 0, sizeof(EMTOrderInsertInfo));
    //报单引用,由客户自定义
    order.order_client_id = 111111;
    //股票代码
    std::string ticker = "131810";
    strncpy(order.ticker, ticker, EMT_TICKER_LEN);
    //市场参数
    order.market = EMT_MKT_SZ_A;
    //委托价格
    order.price = 0.005;
    //数量
    order.quantity = 10;
    //价格类型(回购业务需选择限价类型)
    order.price_type = EMT_PRICE_LIMIT;
    //逆回购方向为 卖
    order.side = EMT_SIDE_SELL;
    //开平标志(除期权外,均使用EMT_POSITION_EFFECT_INIT)
    order.position_effect = EMT_POSITION_EFFECT_INIT;
    //业务类型 回购业务
    order.business_type = EMT_BUSINESS_TYPE_REPO;
    //调用api接口委托前基本校验
    if (m_pTraderApi && session_id != 0)
    {
        //返回报单在EMT系统中的ID,如果为“0”表示报单发送失败
        uint64_t nEmtId = m_pTraderApi->InsertOrder(&order, session_id);
        //下单发送失败
        if (nEmtId == 0)
        {
            //获取错误代码
            EMTRI *error = m_pTraderApi->GetApiLastError();
        }
    }
}
```

## 6. 融资融券业务委托示例

### 6.1 <a>担保品买入</a>
``` cpp
uint64_t InsertOrder(TraderApi* m_pTraderApi, uint64_t session_id)
{
    //EMTOrderInsertInfo 为下单参数结构体
    EMTOrderInsertInfo order;
    //结构体初始化
    memset(&order, 0, sizeof(EMTOrderInsertInfo));
    //报单引用,由客户自定义
    order.order_client_id=111111;
    //股票代码(必须是担保证券,可调用API接口查询哪些是担保证券)
    std::string ticker = "300059";
    strcpy_s(order.ticker, EMT_TICKER_LEN, ticker.c_str());
    //市场参数
    order.market = EMT_MKT_SZ_A;
    //价格(可参考行情修改)
    order.price = 27.5;
    //委托数量
    order.quantity = 1000;
    //价格类型限价(可参考API文档定义类型)
    order.price_type = EMT_PRICE_LIMIT;
    //买卖方向(必须是EMT_SIDE_BUY)
    order.side = EMT_SIDE_BUY;
    //开平标志(除期权外,均使用EMT_POSITION_EFFECT_INIT)
    order.position_effect = EMT_POSITION_EFFECT_INIT;
    //业务类型(是EMT_BUSINESS_TYPE_MARGIN 融资融券业务或EMT_BUSINESS_TYPE_FIXPRICE 盘后定价业务)
    //如果是盘后定价业务,price_type价格类型不可为市价,且证券支持盘后定价
    order.business_type = EMT_BUSINESS_TYPE_MARGIN;
    //调用api接口委托前基本校验
    if(m_pTraderApi && session_id !=0 )
    {
        //返回报单在EMT系统中的ID,如果为“0”表示报单发送失败
        uint64_t nEmtId = m_pTraderApi->InsertOrder(&order, session_id);
        //下单发送失败
        if(nEmtId == 0)
        {
            //获取错误代码
            EMTRI * error = m_pTraderApi->GetApiLastError();
        }
    }
}
```

### 6.2 <a>担保品卖出</a>
``` cpp
uint64_t InsertOrder(TraderApi* m_pTraderApi, uint64_t session_id)
{
    //EMTOrderInsertInfo 为下单参数结构体
    EMTOrderInsertInfo order;
    //结构体初始化
    memset(&order, 0, sizeof(EMTOrderInsertInfo));
    //报单引用,由客户自定义
    order.order_client_id=111111;
    //股票代码
    std::string ticker = "300059";
    strcpy_s(order.ticker, EMT_TICKER_LEN, ticker.c_str());
    //市场参数
    order.market = EMT_MKT_SZ_A;
    //价格(可参考行情修改)
    order.price = 27.5;
    //委托数量
    order.quantity = 1000;
    //价格类型限价(可参考API文档定义类型)
    order.price_type = EMT_PRICE_LIMIT;
    //买卖方向(必须是EMT_SIDE_SELL)
    order.side = EMT_SIDE_SELL;
    //开平标志(除期权外,均使用EMT_POSITION_EFFECT_INIT)
    order.position_effect = EMT_POSITION_EFFECT_INIT;
    //业务类型(是EMT_BUSINESS_TYPE_MARGIN 融资融券业务或EMT_BUSINESS_TYPE_FIXPRICE 盘后定价业务)
    //如果是盘后定价业务,price_type价格类型不可为市价,且证券支持盘后定价
    order.business_type = EMT_BUSINESS_TYPE_MARGIN;
    //调用api接口委托前基本校验
    if(m_pTraderApi && session_id !=0 )
    {
        //返回报单在EMT系统中的ID,如果为“0”表示报单发送失败
        uint64_t nEmtId = m_pTraderApi->InsertOrder(&order, session_id);
        //下单发送失败
        if(nEmtId == 0)
        {
            //获取错误代码
            EMTRI * error = m_pTraderApi->GetApiLastError();
        }
    }
}
```

### 6.3 <a>融资买入</a>
``` cpp
uint64_t InsertOrder(TraderApi* m_pTraderApi, uint64_t session_id)
{
    //EMTOrderInsertInfo 为下单参数结构体
    EMTOrderInsertInfo order;
    //结构体初始化
    memset(&order, 0, sizeof(EMTOrderInsertInfo));
    //报单引用,由客户自定义
    order.order_client_id=111111;
    //股票代码(必须是融资融券标的,可调用API接口查询哪些是融资融券标的)
    std::string ticker = "300059";
    strcpy_s(order.ticker, EMT_TICKER_LEN, ticker.c_str());
    //市场参数
    order.market = EMT_MKT_SZ_A;
    //价格(可参考行情修改)
    order.price = 27.5;
    //委托数量
    order.quantity = 1000;
    //价格类型限价(可参考API文档定义类型)
    order.price_type = EMT_PRICE_LIMIT;
    //买卖方向(必须是EMT_SIDE_MARGIN_TRADE)
    order.side = EMT_SIDE_MARGIN_TRADE;
    //开平标志(除期权外,均使用EMT_POSITION_EFFECT_INIT)
    order.position_effect = EMT_POSITION_EFFECT_INIT;
    //业务类型(是EMT_BUSINESS_TYPE_MARGIN 融资融券业务或EMT_BUSINESS_TYPE_FIXPRICE 盘后定价业务)
    //如果是盘后定价业务,price_type价格类型不可为市价,且证券支持盘后定价
    order.business_type = EMT_BUSINESS_TYPE_MARGIN;
    //调用api接口委托前基本校验
    if(m_pTraderApi && session_id !=0 )
    {
        //返回报单在EMT系统中的ID,如果为“0”表示报单发送失败
        uint64_t nEmtId = m_pTraderApi->InsertOrder(&order, session_id);
        //下单发送失败
        if(nEmtId == 0)
        {
            //获取错误代码
            EMTRI * error = m_pTraderApi->GetApiLastError();
        }
    }
}
```

### 6.4 <a>融券卖出</a>
``` cpp
uint64_t InsertOrder(TraderApi* m_pTraderApi, uint64_t session_id)
{
    //EMTOrderInsertInfo 为下单参数结构体
    EMTOrderInsertInfo order;
    //结构体初始化
    memset(&order, 0, sizeof(EMTOrderInsertInfo));
    //报单引用,由客户自定义
    order.order_client_id=111111;
    //股票代码(必须是融资融券标的,可调用API接口查询哪些是融资融券标的)
    std::string ticker = "300059";
    strcpy_s(order.ticker, EMT_TICKER_LEN, ticker.c_str());
    //市场参数
    order.market = EMT_MKT_SZ_A;
    //价格(不得低于最新成交价)
    order.price = 27.5;
    //委托数量
    order.quantity = 1000;
    //价格类型限价(融券卖出必须是限价)
    order.price_type = EMT_PRICE_LIMIT;
    //买卖方向(必须是EMT_SIDE_SHORT_SELL)
    order.side = EMT_SIDE_SHORT_SELL;
    //开平标志(除期权外,均使用EMT_POSITION_EFFECT_INIT)
    order.position_effect = EMT_POSITION_EFFECT_INIT;
    //业务类型(是EMT_BUSINESS_TYPE_MARGIN 融资融券业务或EMT_BUSINESS_TYPE_FIXPRICE 盘后定价业务)
    //如果是盘后定价业务,price_type价格类型不可为市价,且证券支持盘后定价
    order.business_type = EMT_BUSINESS_TYPE_MARGIN;
    //调用api接口委托前基本校验
    if(m_pTraderApi && session_id !=0 )
    {
        //返回报单在EMT系统中的ID,如果为“0”表示报单发送失败
        uint64_t nEmtId = m_pTraderApi->InsertOrder(&order, session_id);
        //下单发送失败
        if(nEmtId == 0)
        {
            //获取错误代码
            EMTRI * error = m_pTraderApi->GetApiLastError();
        }
    }
}
```

### 6.5 <a>卖券还款</a>
``` cpp
uint64_t InsertOrder(TraderApi* m_pTraderApi, uint64_t session_id)
{
    //EMTOrderInsertInfo 为下单参数结构体
    EMTOrderInsertInfo order;
    //结构体初始化
    memset(&order, 0, sizeof(EMTOrderInsertInfo));
    //报单引用,由客户自定义
    order.order_client_id=111111;
    //股票代码
    std::string ticker = "300059";
    strcpy_s(order.ticker, EMT_TICKER_LEN, ticker.c_str());
    //市场参数
    order.market = EMT_MKT_SZ_A;
    //价格(可参考行情修改)
    order.price = 27.5;
    //委托数量
    order.quantity = 1000;
    //价格类型限价(可参考API文档定义类型)
    order.price_type = EMT_PRICE_LIMIT;
    //买卖方向(必须是EMT_SIDE_REPAY_MARGIN)
    order.side = EMT_SIDE_REPAY_MARGIN;
    //开平标志(除期权外,均使用EMT_POSITION_EFFECT_INIT)
    order.position_effect = EMT_POSITION_EFFECT_INIT;
    //业务类型(是EMT_BUSINESS_TYPE_MARGIN 融资融券业务或EMT_BUSINESS_TYPE_FIXPRICE 盘后定价业务)
    //如果是盘后定价业务,price_type价格类型不可为市价,且证券支持盘后定价
    order.business_type = EMT_BUSINESS_TYPE_MARGIN;
    //调用api接口委托前基本校验
    if(m_pTraderApi && session_id !=0 )
    {
        //返回报单在EMT系统中的ID,如果为“0”表示报单发送失败
        uint64_t nEmtId = m_pTraderApi->InsertOrder(&order, session_id);
        //下单发送失败
        if(nEmtId == 0)
        {
            //获取错误代码
            EMTRI * error = m_pTraderApi->GetApiLastError();
        }
    }
}
```

### 6.6 <a>买券还券</a>
``` cpp
uint64_t InsertOrder(TraderApi* m_pTraderApi, uint64_t session_id)
{
    //EMTOrderInsertInfo 为下单参数结构体
    EMTOrderInsertInfo order;
    //结构体初始化
    memset(&order, 0, sizeof(EMTOrderInsertInfo));
    //报单引用,由客户自定义
    order.order_client_id=111111;
    //股票代码
    std::string ticker = "300059";
    strcpy_s(order.ticker, EMT_TICKER_LEN, ticker.c_str());
    //市场参数
    order.market = EMT_MKT_SZ_A;
    //价格(可参考行情修改)
    order.price = 27.5;
    //委托数量(可能会产生余券)
    order.quantity = 1000;
    //价格类型限价(可参考API文档定义类型)
    order.price_type = EMT_PRICE_LIMIT;
    //买卖方向(必须是EMT_SIDE_REPAY_STOCK)
    order.side = EMT_SIDE_REPAY_STOCK;
    //开平标志(除期权外,均使用EMT_POSITION_EFFECT_INIT)
    order.position_effect = EMT_POSITION_EFFECT_INIT;
    //业务类型(是EMT_BUSINESS_TYPE_MARGIN 融资融券业务或EMT_BUSINESS_TYPE_FIXPRICE 盘后定价业务)
    //如果是盘后定价业务,price_type价格类型不可为市价,且证券支持盘后定价
    order.business_type = EMT_BUSINESS_TYPE_MARGIN;
    //调用api接口委托前基本校验
    if(m_pTraderApi && session_id !=0 )
    {
        //返回报单在EMT系统中的ID,如果为“0”表示报单发送失败
        uint64_t nEmtId = m_pTraderApi->InsertOrder(&order, session_id);
        //下单发送失败
        if(nEmtId == 0)
        {
            //获取错误代码
            EMTRI * error = m_pTraderApi->GetApiLastError();
        }
    }
}
```

### 6.7 <a>现券还券</a>
``` cpp
uint64_t InsertOrder(TraderApi* m_pTraderApi, uint64_t session_id)
{
    //EMTOrderInsertInfo 为下单参数结构体
    EMTOrderInsertInfo order;
    //结构体初始化
    memset(&order, 0, sizeof(EMTOrderInsertInfo));
    //报单引用,由客户自定义
    order.order_client_id=111111;
    //股票代码
    std::string ticker = "300059";
    strcpy_s(order.ticker, EMT_TICKER_LEN, ticker.c_str());
    //市场参数
    order.market = EMT_MKT_SZ_A;
    //委托数量(不可大于非当日的融券负债)
    order.quantity = 1000;
    //买卖方向(必须是EMT_SIDE_STOCK_REPAY_STOCK)
    order.side = EMT_SIDE_STOCK_REPAY_STOCK;
    //开平标志(除期权外,均使用EMT_POSITION_EFFECT_INIT)
    order.position_effect = EMT_POSITION_EFFECT_INIT;
    //业务类型(必须是EMT_BUSINESS_TYPE_MARGIN 融资融券业务)
    order.business_type = EMT_BUSINESS_TYPE_MARGIN;
    //调用api接口委托前基本校验
    if(m_pTraderApi && session_id !=0 )
    {
        //返回报单在EMT系统中的ID,如果为“0”表示报单发送失败
        uint64_t nEmtId = m_pTraderApi->InsertOrder(&order, session_id);
        //下单发送失败
        if(nEmtId == 0)
        {
            //获取错误代码
            EMTRI * error = m_pTraderApi->GetApiLastError();
        }
    }
}
```

### 6.8 <a>担保品转入</a>
``` cpp
uint64_t InsertOrder(TraderApi* m_pTraderApi, uint64_t session_id)
{
    //EMTOrderInsertInfo 为下单参数结构体
    EMTOrderInsertInfo order;
    //结构体初始化
    memset(&order, 0, sizeof(EMTOrderInsertInfo));
    //报单引用,由客户自定义
    order.order_client_id=111111;
    //股票代码(必须是担保证券,可调用API接口查询哪些是担保证券)
    std::string ticker = "300059";
    strcpy_s(order.ticker, EMT_TICKER_LEN, ticker.c_str());
    //市场参数
    order.market = EMT_MKT_SZ_A;
    //委托数量
    order.quantity = 1000;
    //买卖方向(必须是EMT_SIDE_GRTSTK_TRANSIN)
    order.side = EMT_SIDE_GRTSTK_TRANSIN;
    //开平标志(除期权外,均使用EMT_POSITION_EFFECT_INIT)
    order.position_effect = EMT_POSITION_EFFECT_INIT;
    //业务类型(必须是EMT_BUSINESS_TYPE_MARGIN 融资融券业务)
    order.business_type = EMT_BUSINESS_TYPE_MARGIN;
    //调用api接口委托前基本校验
    if(m_pTraderApi && session_id !=0 )
    {
        //返回报单在EMT系统中的ID,如果为“0”表示报单发送失败
        uint64_t nEmtId = m_pTraderApi->InsertOrder(&order, session_id);
        //下单发送失败
        if(nEmtId == 0)
        {
            //获取错误代码
            EMTRI * error = m_pTraderApi->GetApiLastError();
        }
    }
}
```

### 6.9 <a>担保品转出</a>
``` cpp
uint64_t InsertOrder(TraderApi* m_pTraderApi, uint64_t session_id)
{
    //EMTOrderInsertInfo 为下单参数结构体
    EMTOrderInsertInfo order;
    //结构体初始化
    memset(&order, 0, sizeof(EMTOrderInsertInfo));
    //报单引用,由客户自定义
    order.order_client_id=111111;
    //股票代码
    std::string ticker = "300059";
    strcpy_s(order.ticker, EMT_TICKER_LEN, ticker.c_str());
    //市场参数
    order.market = EMT_MKT_SZ_A;
    //委托数量(信用资金购买的证券无法转出,且转出的维保比不能低于提取线)
    order.quantity = 1000;
    //买卖方向(必须是EMT_SIDE_GRTSTK_TRANSOUT)
    order.side = EMT_SIDE_GRTSTK_TRANSOUT;
    //开平标志(除期权外,均使用EMT_POSITION_EFFECT_INIT)
    order.position_effect = EMT_POSITION_EFFECT_INIT;
    //业务类型(必须是EMT_BUSINESS_TYPE_MARGIN 融资融券业务)
    order.business_type = EMT_BUSINESS_TYPE_MARGIN;
    //调用api接口委托前基本校验
    if(m_pTraderApi && session_id !=0 )
    {
        //返回报单在EMT系统中的ID,如果为“0”表示报单发送失败
        uint64_t nEmtId = m_pTraderApi->InsertOrder(&order, session_id);
        //下单发送失败
        if(nEmtId == 0)
        {
            //获取错误代码
            EMTRI * error = m_pTraderApi->GetApiLastError();
        }
    }
}
```

### 6.10 <a>直接还款</a>
``` cpp
uint64_t CreditCashRepay(TraderApi* m_pTraderApi, uint64_t session_id)
{
    //调用api接口委托前基本校验
    if(m_pTraderApi && session_id !=0 )
    {
        double amount =10000;
        //返回报单在EMT系统中的ID,如果为“0”表示报单发送失败
        uint64_t nEmtId = m_pTraderApi->CreditCashRepay(amount, session_id);
        //下单发送失败
        if(nEmtId == 0)
        {
            //获取错误代码
            EMTRI * error = m_pTraderApi->GetApiLastError();
        }
    }
}
```

### 6.11 <a>指定负债还款</a>
``` cpp
uint64_t CreditCashRepaySpecifiedDebt(TraderApi* m_pTraderApi, uint64_t session_id)
{
    //EMTCrdRepaySpecifiedDebtReq 为指定负债还款结构体
    EMTCrdRepaySpecifiedDebtReq order;
    //结构体初始化
    memset(&order, 0, sizeof(EMTCrdRepaySpecifiedDebtReq));
    //偿还金额
    order.request_amount=10000;    
    //合约开仓日期
    order.order_date = 20241205;
    //合约编号
    std::string ticker = "BA00000001";
    strcpy_s(order.debt_id, 16, ticker.c_str());

    //调用api接口委托前基本校验
    if(m_pTraderApi && session_id !=0 )
    {
        //返回报单在EMT系统中的ID,如果为“0”表示报单发送失败
        uint64_t nEmtId = m_pTraderApi->CreditCashRepaySpecifiedDebt(&order, session_id);
        //下单发送失败
        if(nEmtId == 0)
        {
            //获取错误代码
            EMTRI * error = m_pTraderApi->GetApiLastError();
        }
    }
}
```

### 6.12 <a>额度调拨</a>
``` cpp
//该接口只适用于两地分仓的额度调拨
uint64_t CreditQuotaTransfer(TraderApi* m_pTraderApi, uint64_t session_id)
{
    //EMTQuotaTransferReq 为两地分仓信用额度调拨请求
    EMTQuotaTransferReq order;
    //结构体初始化
    memset(&order, 0, sizeof(EMTQuotaTransferReq));
    //资金账号
    std::string fund_account = "100000001";
    strcpy_s(order.fund_account, EMT_ACCOUNT_NAME_LEN, fund_account.c_str());
    //额度划拨金额
    order.amount = 1000;
    //额度划拨类型(支持类型参考API文档EMT_QUOTA_TRANSFER_TYPE)
    order.transfer_type = EMT_STK_QUOTA_TRANSFER_OUT;

    //调用api接口委托前基本校验
    if(m_pTraderApi && session_id !=0 )
    {
        //返回报单在EMT系统中的ID,如果为“0”表示报单发送失败
        uint64_t nEmtId = m_pTraderApi->CreditQuotaTransfer(&order, session_id);
        //下单发送失败
        if(nEmtId == 0)
        {
            //获取错误代码
            EMTRI * error = m_pTraderApi->GetApiLastError();
        }
    }
}
```

# 7. 期权业务委托示例
### 7.1 `<a>`委托买入`</a>`
```cpp
uint64_t InsertOrder(TraderApi* m_pTraderApi, uint64_t session_id)
{
    //EMTOrderInsertInfo 为下单参数结构体
    EMTOrderInsertInfo order;
    //结构体初始化
    memset(&order, 0, sizeof(EMTOrderInsertInfo));
    //报单引用,由客户自定义
    order.order_client_id=111111;
    //合约编码,参考行情
    std::string ticker = "90017369";
    strncpy(order.ticker, ticker.c_str(), EMT_TICKER_LEN);
    //市场参数 EMT_MKT_SH_A 沪市 | EMT_MKT_SZ_A 深市
    order.market = EMT_MKT_SZ_A;
    //价格(可参考行情修改)
    order.price = 2.518;
    //委托数量
    order.quantity = 3;
    //价格类型限价(可参考API文档定义类型)
    order.price_type = EMT_PRICE_LIMIT;
    //买卖方向(必须是EMT_SIDE_BUY)
    order.side = EMT_SIDE_BUY;
    //开平标志：1.开仓|EMT_POSITION_EFFECT_OPEN 2.平仓|EMT_POSITION_EFFECT_CLOSE
    order.position_effect = EMT_POSITION_EFFECT_OPEN;
    //业务类型：EMT_BUSINESS_TYPE_OPTION|期权业务
    order.business_type = EMT_BUSINESS_TYPE_OPTION;
    //调用api接口委托前基本校验
    if(m_pTraderApi && session_id != 0)
    {
        //返回报单在EMT系统中的ID,如果为“0”表示报单发送失败
        uint64_t nEmtId = m_pTraderApi->InsertOrder(&order, session_id);
        //下单发送失败
        if(nEmtId == 0)
        {
            //获取错误代码
            EMTRI * error = m_pTraderApi->GetApiLastError();
            std::cout << "InsertOrder Failed! error code: " << error->error_id << ", error msg: " << error->error_msg << std::endl;
            return 0;
        }
        std::cout << "InsertOrder Success! emt_id: " << nEmtId << std::endl;
        return nEmtId;
    }
    return 0;
}
```

### 7.2 `<a>`委托卖出`</a>`
```cpp
uint64_t InsertOrder(TraderApi* m_pTraderApi, uint64_t session_id)
{
//EMTOrderInsertInfo 为下单参数结构体
    EMTOrderInsertInfo order;
    //结构体初始化
    memset(&order, 0, sizeof(EMTOrderInsertInfo));
    //报单引用,由客户自定义
    order.order_client_id=111111;
    //合约编码(必须是有效合约,可调用API接口查询哪些是有效合约)
    std::string ticker = "90017370";
    strncpy(order.ticker, ticker.c_str(), EMT_TICKER_LEN);
    //市场参数 EMT_MKT_SH_A 沪市 | EMT_MKT_SZ_A 深市
    order.market = EMT_MKT_SZ_A;
    //价格(可参考行情修改)
    order.price = 2.517;
    //委托数量
    order.quantity = 1;
    //价格类型限价(可参考API文档定义类型)
    order.price_type = EMT_PRICE_LIMIT;
    //买卖方向(必须是EMT_SIDE_SELL)
    order.side = EMT_SIDE_SELL;
    //开平标志：1.开仓|EMT_POSITION_EFFECT_OPEN 2.平仓|EMT_POSITION_EFFECT_CLOSE
    order.position_effect = EMT_POSITION_EFFECT_OPEN;
    //业务类型：EMT_BUSINESS_TYPE_OPTION|期权业务
    order.business_type = EMT_BUSINESS_TYPE_OPTION;
    //调用api接口委托前基本校验
    if(m_pTraderApi && session_id != 0)
    {
        //返回报单在EMT系统中的ID,如果为“0”表示报单发送失败
        uint64_t nEmtId = m_pTraderApi->InsertOrder(&order, session_id);
        //下单发送失败
        if(nEmtId == 0)
        {
            //获取错误代码
            EMTRI * error = m_pTraderApi->GetApiLastError();
            std::cout << "InsertOrder Failed! error code: " << error->error_id << ", error msg: " << error->error_msg << std::endl;
            return 0;
        }
        std::cout << "InsertOrder Success! emt_id: " << nEmtId << std::endl;
        return nEmtId;
    }
    return 0;
}
```

### 7.3 `<a>`证券锁定`</a>`
```cpp
uint64_t InsertOrder(TraderApi* m_pTraderApi, uint64_t session_id)
{
//EMTOrderInsertInfo 为下单参数结构体
    EMTOrderInsertInfo order;
    //结构体初始化
    memset(&order, 0, sizeof(EMTOrderInsertInfo));
    //报单引用,由客户自定义
    order.order_client_id=111111;
    //业务类型：EMT_BUSINESS_TYPE_FREEZE|锁定解锁
    order.business_type = EMT_BUSINESS_TYPE_FREEZE;
    // 证券标的，非合约代码
    std::string ticker = "510500";
    strncpy(order.ticker, ticker.c_str(), EMT_TICKER_LEN);
    //市场参数 EMT_MKT_SH_A 沪市, 仅支持沪市
    order.market = EMT_MKT_SH_A;
    //买卖方向(必须是EMT_SIDE_FREEZE)
    order.side = EMT_SIDE_FREEZE;
    //开平标志：1.开仓|锁定|EMT_POSITION_EFFECT_OPEN 2.平仓|解锁|EMT_POSITION_EFFECT_CLOSE
    order.position_effect = EMT_POSITION_EFFECT_OPEN;
    //价格(默认值)
    order.price = 0.0;
    //委托数量
    order.quantity = 1;
    //价格类型限价(可参考API文档定义类型，默认EMT_PRICE_LIMIT)
    order.price_type = EMT_PRICE_LIMIT;

    //调用api接口委托前基本校验
    if(m_pTraderApi && session_id != 0)
    {
        //返回报单在EMT系统中的ID,如果为“0”表示报单发送失败
        uint64_t nEmtId = m_pTraderApi->InsertOrder(&order, session_id);
        //下单发送失败
        if(nEmtId == 0)
        {
            //获取错误代码
            EMTRI * error = m_pTraderApi->GetApiLastError();
            std::cout << "InsertOrder Failed! error code: " << error->error_id << ", error msg: " << error->error_msg << std::endl;
            return 0;
        }
        std::cout << "InsertOrder Success! emt_id: " << nEmtId << std::endl;
        return nEmtId;
    }
    return 0;
}
```

### 7.4 `<a>`证券解锁`</a>`
```cpp
uint64_t InsertOrder(TraderApi* m_pTraderApi, uint64_t session_id)
{
    //EMTOrderInsertInfo 为下单参数结构体
    EMTOrderInsertInfo order;
    //结构体初始化
    memset(&order, 0, sizeof(EMTOrderInsertInfo));
    //报单引用,由客户自定义
    order.order_client_id=111111;
    //业务类型：EMT_BUSINESS_TYPE_FREEZE|锁定解锁
    order.business_type = EMT_BUSINESS_TYPE_FREEZE;
    // 证券标的，非合约代码
    std::string ticker = "510500";
    strncpy(order.ticker, ticker.c_str(), EMT_TICKER_LEN);
    //市场参数 EMT_MKT_SH_A 沪市, 仅支持沪市
    order.market = EMT_MKT_SH_A;
    //买卖方向(必须是EMT_SIDE_FREEZE)
    order.side = EMT_SIDE_FREEZE;
    //开平标志：1.开仓|锁定|EMT_POSITION_EFFECT_OPEN 2.平仓|解锁|EMT_POSITION_EFFECT_CLOSE
    order.position_effect = EMT_POSITION_EFFECT_CLOSE;
    //价格(默认值)
    order.price = 0.0;
    //委托数量
    order.quantity = 1;
    //价格类型限价(可参考API文档定义类型，默认EMT_PRICE_LIMIT)
    order.price_type = EMT_PRICE_LIMIT;

    //调用api接口委托前基本校验
    if(m_pTraderApi && session_id != 0)
    {
        //返回报单在EMT系统中的ID,如果为“0”表示报单发送失败
        uint64_t nEmtId = m_pTraderApi->InsertOrder(&order, session_id);
        //下单发送失败
        if(nEmtId == 0)
        {
            //获取错误代码
            EMTRI * error = m_pTraderApi->GetApiLastError();
            std::cout << "InsertOrder Failed! error code: " << error->error_id << ", error msg: " << error->error_msg << std::endl;
            return 0;
        }
        std::cout << "InsertOrder Success! emt_id: " << nEmtId << std::endl;
        return nEmtId;
    }
    return 0;
}
```

### 7.5 `<a>`备兑委托`</a>`
```cpp
uint64_t InsertOrder(TraderApi* m_pTraderApi, uint64_t session_id)
{
    //EMTOrderInsertInfo 为下单参数结构体
    EMTOrderInsertInfo order;
    //结构体初始化
    memset(&order, 0, sizeof(EMTOrderInsertInfo));
    //报单引用,由客户自定义
    order.order_client_id=111111;
    //业务类型：EMT_BUSINESS_TYPE_OPTION|期权
    order.business_type = EMT_BUSINESS_TYPE_OPTION;
    // 合约编码（8位代码）, 认沽期权不允许备兑
    std::string ticker = "11057930";
    strncpy(order.ticker, ticker.c_str(), EMT_TICKER_LEN);
    //市场参数 EMT_MKT_SH_A 沪市（沪市需要先做证券锁定，后备兑），深市直接备兑开仓
    order.market = EMT_MKT_SH_A;
    //买卖方向(必须是EMT_SIDE_COVER|备兑)
    order.side = (EMT_SIDE_TYPE)EMT_SIDE_COVER;
    //开平标志：1.开仓|锁定|EMT_POSITION_EFFECT_OPEN 2.平仓|解锁|EMT_POSITION_EFFECT_CLOSE
    // 开仓|备兑卖出，平仓|备兑买入
    order.position_effect = (EMT_POSITION_EFFECT_TYPE)EMT_POSITION_EFFECT_OPEN;
    //价格(取行情价）
    order.price = 181.2;
    //委托数量
    order.quantity = 1;
    //价格类型限价(可参考API文档定义类型)
    order.price_type = EMT_PRICE_LIMIT;
    //调用api接口委托前基本校验
    if(m_pTraderApi && session_id != 0)
    {
        //返回报单在EMT系统中的ID,如果为“0”表示报单发送失败
        uint64_t nEmtId = m_pTraderApi->InsertOrder(&order, session_id);
        //下单发送失败
        if(nEmtId == 0)
        {
            //获取错误代码
            EMTRI * error = m_pTraderApi->GetApiLastError();
            std::cout << "InsertOrder Failed! error code: " << error->error_id << ", error msg: " << error->error_msg << std::endl;
            return 0;
        }
        std::cout << "InsertOrder Success! emt_id: " << nEmtId << std::endl;
        return nEmtId;
    }
    return 0;
}
```

### 7.6 `<a>`组合委托`</a>`
```cpp
uint64_t InsertCombOrder(TraderApi* m_pTraderApi, uint64_t session_id)
{
    //EMTOptCombOrderInsertInfo 为下单参数结构体
    EMTOptCombOrderInsertInfo order;
    memset(&order, 0, sizeof(EMTOptCombOrderInsertInfo));
    //报单引用,由客户自定义
    order.order_client_id=111111;
    //市场参数 EMT_MKT_SH_A 沪市 | EMT_MKT_SZ_A 深市
    order.market = EMT_MKT_SZ_A;
    //业务类型：EMT_BUSINESS_TYPE_OPTION_COMBINE|期权组合策略 组合和拆分业务
    order.business_type = EMT_BUSINESS_TYPE_OPTION_COMBINE;
    //买卖方向（必须是EMT_SIDE_OPT_COMBINE）: EMT_SIDE_OPT_COMBINE|组合 , EMT_SIDE_OPT_SPLIT|拆分
    order.side = EMT_SIDE_OPT_COMBINE;
    //委托数量
    order.quantity = 1;
    //组合策略代码，比如CNSJC认购牛市价差策略等
    strncpy(order.opt_comb_info.strategy_id, "CNSJC", sizeof(order.opt_comb_info.strategy_id));
    //成分合约数, <= 2
    order.opt_comb_info.num_legs = 2;
    // 成分合约1
    {
        // 成分合约代码，合约代码参考当日合约
        strncpy(order.opt_comb_info.leg_detail[0].leg_security_id, "90017369", sizeof(order.opt_comb_info.leg_detail[0].leg_security_id));
        // 成分合约类型 EMT_OPT_CALL|认购 或 EMT_OPT_PUT|认沽
        order.opt_comb_info.leg_detail[0].leg_cntr_type = (EMT_OPT_CALL_OR_PUT_TYPE)EMT_OPT_CALL;
        // 成分合约持仓方向 权利方或义务方
        // EMT_POSITION_DIRECTION_LONG|多（期权则为权利方）, EMT_POSITION_DIRECTION_SHORT|空（期权则为义务方）
        // EMT_POSITION_DIRECTION_COVERED|备兑（期权则为备兑义务方）
        order.opt_comb_info.leg_detail[0].leg_side = (EMT_POSITION_DIRECTION_TYPE)EMT_POSITION_DIRECTION_LONG;
        // 备兑标签，持仓方向为备兑时,填写备兑标识；EMT_POSITION_UNCOVERED|非备兑，EMT_POSITION_COVERED|备兑
        order.opt_comb_info.leg_detail[0].leg_covered = (EMT_OPT_COVERED_OR_UNCOVERED)EMT_POSITION_UNCOVERED;
        // 成分合约数量
        order.opt_comb_info.leg_detail[0].leg_qty = 1;
    }
    // 成分合约2
    {
        // 成分合约代码, 合约代码参考当日合约
        strncpy(order.opt_comb_info.leg_detail[1].leg_security_id, "90017370", sizeof(order.opt_comb_info.leg_detail[1].leg_security_id));
        // 成分合约类型 EMT_OPT_CALL|认购 或 EMT_OPT_PUT|认沽
        order.opt_comb_info.leg_detail[1].leg_cntr_type = (EMT_OPT_CALL_OR_PUT_TYPE)EMT_OPT_CALL;
        // 成分合约持仓方向 权利方或义务方
        // EMT_POSITION_DIRECTION_LONG|多（期权则为权利方）, EMT_POSITION_DIRECTION_SHORT|空（期权则为义务方）
        // EMT_POSITION_DIRECTION_COVERED|备兑（期权则为备兑义务方）
        order.opt_comb_info.leg_detail[1].leg_side = (EMT_POSITION_DIRECTION_TYPE)EMT_POSITION_DIRECTION_SHORT;
        // 备兑标签，持仓方向为备兑时,填写备兑标识；EMT_POSITION_UNCOVERED|非备兑，EMT_POSITION_COVERED|备兑
        order.opt_comb_info.leg_detail[1].leg_covered = (EMT_OPT_COVERED_OR_UNCOVERED)EMT_POSITION_UNCOVERED;
        // 成分合约数量
        order.opt_comb_info.leg_detail[1].leg_qty = 1;
    }

    //调用api接口委托前基本校验
    if(m_pTraderApi && session_id != 0)
    {
        //返回报单在EMT系统中的ID,如果为“0”表示报单发送失败
        uint64_t nEmtId = m_pTraderApi->InsertOptionCombinedOrder(&order, session_id);
        //下单发送失败
        if(nEmtId == 0)
        {
            //获取错误代码
            EMTRI * error = m_pTraderApi->GetApiLastError();
            std::cout << "InsertCombOrder Failed! error code: " << error->error_id << ", error msg: " << error->error_msg << std::endl;
            return 0;
        }
        std::cout << "InsertCombOrder Success! emt_id: " << nEmtId << std::endl;
        return nEmtId;
    }
    return 0;
}
```

### 7.7 `<a>`拆分委托`</a>`
```cpp
uint64_t InsertSplitOrder(TraderApi* m_pTraderApi, uint64_t session_id)
{
    //EMTOptCombOrderInsertInfo 为下单参数结构体
    EMTOptCombOrderInsertInfo order;
    memset(&order, 0, sizeof(EMTOptCombOrderInsertInfo));
    //报单引用,由客户自定义
    order.order_client_id=111111;
    //市场参数 EMT_MKT_SH_A 沪市 | EMT_MKT_SZ_A 深市
    order.market = EMT_MKT_SZ_A;
    //业务类型：EMT_BUSINESS_TYPE_OPTION_COMBINE|期权组合策略 组合和拆分业务
    order.business_type = EMT_BUSINESS_TYPE_OPTION_COMBINE;
    //买卖方向（必须是EMT_SIDE_OPT_SPLIT）: EMT_SIDE_OPT_COMBINE|组合 , EMT_SIDE_OPT_SPLIT|拆分
    order.side = EMT_SIDE_OPT_SPLIT;
    //委托数量
    order.quantity = 1;
    //组合策略代码，比如CNSJC认购牛市价差策略等
    strncpy(order.opt_comb_info.strategy_id, "CNSJC", sizeof(order.opt_comb_info.strategy_id));
    // 组合编码，组合委托后返回或查询委托可以获得
    strncpy(order.opt_comb_info.comb_num, "2024123010003375", sizeof(order.opt_comb_info.comb_num));
    //成分合约数(目前交易所仅支持2)
    order.opt_comb_info.num_legs = 2;
    // 成分合约1
    {
        // 成分合约代码，合约代码参考当日合约
        strncpy(order.opt_comb_info.leg_detail[0].leg_security_id, "90017369", sizeof(order.opt_comb_info.leg_detail[0].leg_security_id));
        // 成分合约类型 EMT_OPT_CALL|认购 或 EMT_OPT_PUT|认沽
        order.opt_comb_info.leg_detail[0].leg_cntr_type = (EMT_OPT_CALL_OR_PUT_TYPE)EMT_OPT_CALL;
        // 成分合约持仓方向 权利方或义务方
        // EMT_POSITION_DIRECTION_LONG|多（期权则为权利方）, EMT_POSITION_DIRECTION_SHORT|空（期权则为义务方）
        // EMT_POSITION_DIRECTION_COVERED|备兑（期权则为备兑义务方）
        order.opt_comb_info.leg_detail[0].leg_side = (EMT_POSITION_DIRECTION_TYPE)EMT_POSITION_DIRECTION_LONG;
        // 备兑标签，持仓方向为备兑时,填写备兑标识；EMT_POSITION_UNCOVERED|非备兑，EMT_POSITION_COVERED|备兑
        order.opt_comb_info.leg_detail[0].leg_covered = (EMT_OPT_COVERED_OR_UNCOVERED)EMT_POSITION_UNCOVERED;
        // 成分合约数量
        order.opt_comb_info.leg_detail[0].leg_qty = 1;
    }
    // 成分合约2
    {
        // 成分合约代码, 合约代码参考当日合约
        strncpy(order.opt_comb_info.leg_detail[1].leg_security_id, "90017370", sizeof(order.opt_comb_info.leg_detail[1].leg_security_id));
        // 成分合约类型 EMT_OPT_CALL|认购 或 EMT_OPT_PUT|认沽
        order.opt_comb_info.leg_detail[1].leg_cntr_type = (EMT_OPT_CALL_OR_PUT_TYPE)EMT_OPT_CALL;
        // 成分合约持仓方向 权利方或义务方
        // EMT_POSITION_DIRECTION_LONG|多（期权则为权利方）, EMT_POSITION_DIRECTION_SHORT|空（期权则为义务方）
        // EMT_POSITION_DIRECTION_COVERED|备兑（期权则为备兑义务方）
        order.opt_comb_info.leg_detail[1].leg_side = (EMT_POSITION_DIRECTION_TYPE)EMT_POSITION_DIRECTION_SHORT;
        // 备兑标签，持仓方向为备兑时,填写备兑标识；EMT_POSITION_UNCOVERED|非备兑，EMT_POSITION_COVERED|备兑
        order.opt_comb_info.leg_detail[1].leg_covered = (EMT_OPT_COVERED_OR_UNCOVERED)EMT_POSITION_UNCOVERED;
        // 成分合约数量
        order.opt_comb_info.leg_detail[1].leg_qty = 1;
    }

    //调用api接口委托前基本校验
    if(m_pTraderApi && session_id != 0)
    {
        //返回报单在EMT系统中的ID,如果为“0”表示报单发送失败
        uint64_t nEmtId = m_pTraderApi->InsertOptionCombinedOrder(&order, session_id);
        //下单发送失败
        if(nEmtId == 0)
        {
            //获取错误代码
            EMTRI * error = m_pTraderApi->GetApiLastError();
            std::cout << "InsertSplitOrder Failed! error code: " << error->error_id << ", error msg: " << error->error_msg << std::endl;
            return 0;
        }
        std::cout << "InsertSplitOrder Success! emt_id: " << nEmtId << std::endl;
        return nEmtId;
    }
    return 0;
}
```

### 7.8 `<a>`行权`</a>`
```cpp
uint64_t InsertExerciseOrder(TraderApi* m_pTraderApi, uint64_t session_id)
{
    //EMTOptionExerciseOrderInsertInfo 为下单参数结构体
    EMTOptionExerciseOrderInsertInfo order;
     //结构体初始化
    memset(&order, 0, sizeof(EMTOrderInsertInfo));
    //报单引用,由客户自定义
    order.order_client_id=111111;
    //市场参数 EMT_MKT_SH_A 沪市 | EMT_MKT_SZ_A 深市
    order.market = EMT_MKT_SZ_A;
    //委托数量
    order.quantity = 1;
    // 业务类型: EMT_BUSINESS_TYPE_EXECUTE|行权, EMT_BUSINESS_TYPE_EXECUTE_COMBINE|组合行权
    order.business_type = EMT_BUSINESS_TYPE_EXECUTE;
    //合约代码 客户端请求不带空格，以'\0'结尾 行权仅填写第一个，组合行权填写两个合约ID
    strncpy(order.ticker[0], "90017369", EMT_TICKER_LEN);
    //调用api接口委托前基本校验
    if(m_pTraderApi && session_id != 0)
    {
        //返回报单在EMT系统中的ID,如果为“0”表示报单发送失败
        uint64_t nEmtId = m_pTraderApi->InsertOptionExerciseOrder(&order, session_id);
        //下单发送失败
        if(nEmtId == 0)
        {
            //获取错误代码
            EMTRI * error = m_pTraderApi->GetApiLastError();
            std::cout << "InsertExerciseOrder Failed! error code: " << error->error_id << ", error msg: " << error->error_msg << std::endl;
            return 0;
        }
        std::cout << "InsertExerciseOrder Success! emt_id: " << nEmtId << std::endl;
        return nEmtId;
    }
    return 0;
}
```

### 7.8 `<a>`组合行权`</a>`
```cpp
uint64_t InsertCombExerciseOrder(TraderApi* m_pTraderApi, uint64_t session_id)
{
    //EMTOptionExerciseOrderInsertInfo 为下单参数结构体
    EMTOptionExerciseOrderInsertInfo order;
     //结构体初始化
    memset(&order, 0, sizeof(EMTOrderInsertInfo));
    //报单引用,由客户自定义
    order.order_client_id=111111;
    //市场参数 EMT_MKT_SH_A 沪市 | EMT_MKT_SZ_A 深市
    order.market = EMT_MKT_SZ_A;
    //委托数量
    order.quantity = 1;
    // 业务类型: EMT_BUSINESS_TYPE_EXECUTE|行权, EMT_BUSINESS_TYPE_EXECUTE_COMBINE|组合行权
    order.business_type = EMT_BUSINESS_TYPE_EXECUTE_COMBINE;
    //合约代码 客户端请求不带空格，以'\0'结尾 行权仅填写第一个，组合行权填写两个合约ID
    strncpy(order.ticker[0], "90017369", EMT_TICKER_LEN);
    strncpy(order.ticker[1], "90017370", EMT_TICKER_LEN);
    //调用api接口委托前基本校验
    if(m_pTraderApi && session_id != 0)
    {
        //返回报单在EMT系统中的ID,如果为“0”表示报单发送失败
        uint64_t nEmtId = m_pTraderApi->InsertOptionExerciseOrder(&order, session_id);
        //下单发送失败
        if(nEmtId == 0)
        {
            //获取错误代码
            EMTRI * error = m_pTraderApi->GetApiLastError();
            std::cout << "InsertCombExerciseOrder Failed! error code: " << error->error_id << ", error msg: " << error->error_msg << std::endl;
            return 0;
        }
        std::cout << "InsertCombExerciseOrder Success! emt_id: " << nEmtId << std::endl;
        return nEmtId;
    }
    return 0;
}
```

## 8. 资金划拨示例

```c++
uint64_t FundTranser(TraderApi* m_pTraderApi, uint64_t session_id)
{
    //EMTFundTransferReq 为指资金划拨请求结构体
    EMTFundTransferReq order;
    //结构体初始化
    memset(&order, 0, sizeof(EMTFundTransferReq));
    //资金账号
    std::string fund_account = "100000001";
    strncpy(order.fund_account, fund_account.c_str(), EMT_ACCOUNT_NAME_LEN);
    //划拨金额
    order.amount = 1000;
    //划拨类型(支持类型参考API文档EMT_FUND_TRANSFER_TYPE,期权仅支持EMT_FUND_INTER_TRANSFER_OUT和EMT_FUND_INTER_TRANSFER_IN)
    order.transfer_type = EMT_FUND_INTER_TRANSFER_OUT;
    //调用api接口委托前基本校验
    if(m_pTraderApi && session_id != 0 )
    {
        //返回资金划拨记录ID,如果为“0”表示资金划拨发送失败
        uint64_t nTransferId = m_pTraderApi->FundTranser(&order, session_id);
        //下单发送失败
        if(nTransferId == 0)
        {
            //获取错误代码
            EMTRI * error = m_pTraderApi->GetApiLastError();
        }
    }
}
```
